#!/usr/bin/env perl 

#=====================================================================
# Transfer files from UPPMAX's project MASTER_INBOX to designated
# MASTER_INBOX folder on NRM.
# Use `backup2nrm -h`, or `perldoc backup2nrm`, or see end of this
# file for description.
#=====================================================================

use strict;
use warnings;
#use Data::Dumper;
use Getopt::Long;

my $nrmuser          = '';                       # Provide your NRM user name here ('joebro')
my $mailuser         = '';                       # Provide your e-mail address here ('joe.brown@email.com')
my $nrmcomputer      = '';                       # Provide the name of the NRM backup computer here ('xxxx.nrm.se')
my $nrmpath          = '';                       # Confirm path with NRM-IT ('/dnadata/projects')!
my $cpuaccount       = '';                       # Account ID for CPU hours on UPPMAX ('snicxxxx-x-xxx')
my $findmasterinbox  = '';                       # Locate MASTER_INBOX recursively starting in this location ('/proj/sllstorexxxxxxx').
my $VERBOSE          = 1;                        # Set to 0 for noverbose
my $timedefault      = '10:00:00';               # Default time (h:mm:ss)
my $mbsdef           = '20';                     # Default assumed transfer speed (20 MB/sec)
my $rsynccmd         = 'rsync -av -h --exclude=".DS_Store" --exclude="._.DS_Store" -P '; # Testing standard settings.  See END comments.
my $rsynccmd_ssh     = ' ';                      # " -e \'ssh -T -c aes128-gcm\@openssh.com -o Compression=no -x\' ";
my $sbatchcmd        = 'sbatch';
my $uppmax           = $ENV{HOSTNAME};           # 'rackham.uppmax.uu.se',
my $whoami           = $ENV{USER};
my $uppmax_user      = $whoami;
my $autotime         = 1;                        # Autotime is multiplied by an integer (see GetOptions arg below) 
my $submit           = 1;                        # Submit script to SLURM (1) or not (0)
my $time             = q{};
my $infile           = q{};
my $masterinbox      = q{};
my $pids             = q{};
my $nrmcomputer_user = q{};
my $mbs              = q{};
my $date             = prettydate();
my %HoH              = ();

GetOptions(
    "autotime:3"        => \$autotime,
    "cpuaccount=s"      => \$cpuaccount,
    "mail-user=s"       => \$mailuser,
    "nrm-user:s"        => \$nrmuser,
    "submit!"           => \$submit,
    "time=s"            => \$time,
    "verbose!"          => \$VERBOSE,
    "findmasterinbox=s" => \$findmasterinbox,
    "help"              => sub { exec("perldoc", $0); exit(0); },
);

if ($findmasterinbox) {
    if (! -d $findmasterinbox) {
        die "Error: Can not locate directory $findmasterinbox.\nNeed to provide correct path to where to start looking for MASTER_INBOX.\n";
    }
    else {
        $masterinbox = find_master_inbox($findmasterinbox);
    }
}

if ($nrmpath =~ /\/$/) {
    $nrmpath =~ s/\/$//;
}

if ($nrmuser) {
    $nrmcomputer_user = $nrmuser . '@nrm.se';
}
else {
    $nrmuser = $uppmax_user; # Try uppmax user. Might fail!
    $nrmcomputer_user = $uppmax_user . '@nrm.se';
}

if ($time) {
    $time = $time;
}
else {
    $time = $timedefault;
}

$rsynccmd = $rsynccmd . $rsynccmd_ssh;

if ($masterinbox) {
    populate_hash($masterinbox);
}
else {
    while (my $string = shift) {
        chomp($string);
        $string =~ s/\/$//;
        populate_hash($string);
    }
}

my $i = 0;
foreach my $string (sort keys %HoH) {
    my $projectid = $HoH{$string}->{'projectid'};
    my $source = $HoH{$string}->{'source'};
    my $destination = $HoH{$string}->{'destination'};
    my $folder = $HoH{$string}->{'folder'};
    my $jobname = 'rsync-' . $date . '.' . $i . '-' . $folder . '-' . $projectid;
    my $outfile = $jobname . '.slurm';

    print STDERR "Transfer files from $uppmax to $nrmcomputer:\n" if $VERBOSE;
    print STDERR "\n" if $VERBOSE;
    print STDERR "    $source -> $destination\n" if $VERBOSE;
    print STDERR "\n" if $VERBOSE;

    open (my $PRINT, '>', $outfile) or die "$0 : Failed to open output file $outfile : $!\n\n";
    print $PRINT '#!/bin/bash -l', "\n";
    print $PRINT "\n";
    print $PRINT "## backup2nrm script created $date\n";
    print $PRINT "## Transfer files from $uppmax to $nrmcomputer:\n";
    print $PRINT "##\n";
    print $PRINT "##    $source -> $destination\n";
    print $PRINT "##\n";
    print $PRINT "## Run script on UPPMAX by: sbatch --test-only $outfile\n";
    print $PRINT "##                and then: sbatch $outfile\n";
    print $PRINT "## Monitor slurm status by:\n";
    print $PRINT "##    jobinfo -u $uppmax_user\n";
    print $PRINT "## Cancel slurm job by:\n";
    print $PRINT "##    scancel <JOBID>\n";
    print $PRINT "##    scancel -i -u $uppmax_user\n";
    print $PRINT "##    scancel --state=pending -u $uppmax_user\n";
    print $PRINT "\n";
    print $PRINT "#SBATCH -J $jobname\n";
    print $PRINT "#SBATCH -A $cpuaccount\n";
    if ($autotime) {
        $time = setautotime($source, $destination, $autotime); 
    }
    print $PRINT "#SBATCH -t $time\n";
    print $PRINT "#SBATCH -p core\n";
    print $PRINT "#SBATCH -n 1\n";
    if ($mailuser) {
        print $PRINT "#SBATCH --mail-type=BEGIN,END,FAIL --mail-user=$mailuser\n";
    }
    print $PRINT "\n";
    print $PRINT "## $string\n";
    print $PRINT $rsynccmd, ' ', $source, ' ', '"', $nrmcomputer_user, '"', '@', $nrmcomputer, ':', $destination, "\n";
    print $PRINT "\n";
    close($PRINT);

    if ($outfile) {
        if(-e $outfile) {
            chmod 0755, $outfile;
            print STDERR "\nCreated file $outfile\n" if $VERBOSE;
            if ($submit) {
                system($sbatchcmd, $outfile); # Not checking system submit status
                print STDERR "Submitted script $outfile to SLURM.\n" if $VERBOSE;
                print STDERR "\nCheck status by using, e.g.,\n\n  jobinfo -u $uppmax_user\n" if $VERBOSE;
                print STDERR "\nCancel job by using, e.g.,\n\n  scancel -u $uppmax_user -i\n" if $VERBOSE;
            }
            else {
                print "\nRun the script on uppmax by first checking:\n\n  sbatch --test-only $outfile\n\n";
                print "and then submitting:\n\n  sbatch $outfile\n\n";
            }
        }
        else {
            die "Could not create script file $outfile : $! \n";
        }
    }
    $i++;
}


sub populate_hash {
    ## Reads string (path or name) and populates hash
    # String is now meant to be either:
    # "sllstore2017093"
    # "/proj/sllstore2017093"
    # "/proj/sllstore2017093/MASTER_INBOX"

    my ($string) = (@_);
    my ($destination_path, $h, $p, $projid, $folder, @restpath);
    my $projINBOXpath = '/proj/' . $string . '/MASTER_INBOX';

    ## If string starts with /proj and points to an existing folder (i.e. full path)
    if (($string =~ /^\/proj\//) and (-d "$string")) {
        if (($h, $p, $projid, @restpath) = split /\//, $string) {
            $folder = pop(@restpath);
            chomp($folder);
            $destination_path = join('/', $projid, @restpath);
            $destination_path = $nrmpath . '/' . $nrmuser . '/' . $destination_path;
            $HoH{$string}{'folder'} = $folder;
            $HoH{$string}{'source'} = $string;
            $HoH{$string}{'destination'} = $destination_path;
            $HoH{$string}{'projectid'} = $projid;
        }
        else {
            die "Error: Could not read path from string \"$string\"\n";
        }
    }
    elsif (-d "$projINBOXpath") {
        $destination_path = $nrmpath . '/' . $nrmuser . '/' . $string;
        $HoH{$string}{'folder'} = 'MASTER_INBOX';
        $HoH{$string}{'source'} = $projINBOXpath;
        $HoH{$string}{'destination'} = $destination_path;
        $HoH{$string}{'projectid'} = $string;
    }
    else {
        die "Error: does folder (or project) \"$string\" exist?\n";
    }
}

sub prettydate {
    ## Returns date string, e.g. "01122015"
    @_ = localtime(shift || time);
    return(sprintf("%02d%02d%04d", $_[3], $_[4]+1, $_[5]+1900));
}

sub setautotime {
    ## Returns time string (D-H:MM:SS), e.g. "0-3:00:00"
    ## Time calculated from size to be transferred and
    ## average transfer speed times an extra constant ($extra)
    ## Returns time string (D-H:MM:SS), e.g. "0-3:00:00"
    my ($src, $dest, $extra) = (@_);
    my $size = 0;
    my $speed = 0;
    my $cmd = 'rsync -an --stats';
    $cmd = $cmd . ' ' . $src . ' ' . "--exclude=\'.DS_Store\' --exclude=\'._.DS_Store\'" . ' ' . "\"$nrmcomputer_user\"" . '@' . "$nrmcomputer:$dest";
    my @output = `$cmd`;
    chomp @output;
    foreach (@output) {
        if (/Total\s+transferred\s+file\s+size:\s+([\d|,]+)\s+bytes/) {
            $size = $1;
            $size =~ s/,//g;
        }
        elsif (/total\s+size\s+is\s+([\d|,]+)\s+/) {
            $size = $1;
            $size =~ s/,//g;
        }
    }
    my $mbs = dd();
    $speed = $mbs * (1024 * 1024); # MB/s to bytes/s
    my $transfertime = ($size / $speed) * $extra;
    my $s = sprintf "%d", $transfertime;
    return sprintf "0-00:00:%02d", $s if ($s < 60);
    my $m = $s / 60;
    $s %= 60;
    return sprintf "0-00:%02d:%02d", $m, $s if ($m < 60);
    my $h = $m / 60;
    $m %= 60;
    return sprintf "0-%02d:%02d:%02d", $h, $m, $s if ($h < 24);
    my $d = $h / 24;
    $h %= 24;
    return sprintf "%d-%02d:%02d:%02d", $d, $h, $m, $s;
}

sub dd {
    ## Returns MB/s string, e.g. "92.4".
    ## Test connection speed by sending 1M data to destination.
    ## Uses 'dd' and 'ssh'. Reads from '/dev/zero' on source,
    ## and writes to '/dev/null' on destination
    my $mbs = 0;
    print STDERR "Testing connection speed. Might take a moment.\n";
    system("dd if=/dev/zero count=1k bs=1M 2>tmp.stderr.tmp | ssh $nrmcomputer_user\@$nrmcomputer \'cat>/dev/null\'");
    open my $fh, "<", "tmp.stderr.tmp" or die "could not open tmp.stderr: $!\n";
    while(<$fh>) {
        if (m/([\d|\.]+) MB\/s/) {
            $mbs = $1; 
        }
    }   
    close($fh);
    unlink("tmp.stderr.tmp");
    return $mbs;
}

sub find_master_inbox {
    ## Arg is path to start searching: '/proj/sllstore2017093/'
    ## Need a trailing slash.
    ## Note redirection of all errs to /dev/null
    ## Reads an arbitrary number of lines
    my ($searchpath) = (@_);
    if ($searchpath !~ /\/$/) {
        $searchpath = $searchpath . '/';
    }   
    open FIND, "find $searchpath -maxdepth 4 -type d -name MASTER_INBOX -print -quit 2>/dev/null |";
    read FIND, my $find_output, 99;
    close FIND;
    my @boxes = split(/\n/, $find_output);
    my $box = join('', @boxes);
    return $box;
}


=pod

=head1 NAME

backup2nrm - Backup Files to NRM

=head1 VERSION

Version Wed 12 Dec 2018

=head1 SYNOPSIS

 backup2nrm [options] [/path/to/folder|project_id]

=head1 EXAMPLES

B<Transfer files in C</proj/sllstore2017xxx/MASTER_INBOX>>

  backup2nrm sllstore2017xxx

B<Transfer files in specific folder (full path!)>

  backup2nrm /proj/sllstore2017xxx/MASTER_INBOX

B<Specify username on NRM, and e-mail address for messages (from UPPMAX)>

  backup2nrm -s -n nrmuser -m a.name@email.com sllstore2017xxx

B<Submit generated slurm script, use auto-generation of estimated transfer time.>

  backup2nrm -s -a sllstore2017xxx

=head1 DESCRIPTION

The C<backup2nrm>-script generates a script (in the current working directory) with instructions 
on how to transfer files from UPPMAX to NRM.

Review the generated transfer-script and if found appropriate, submit the script to the SLURM system.

The C<backup2nrm>-script has a number of options that could be of use (see B<OPTIONS> below). 

Either the full path to the source folder should be provided as argument, or the (UPPMAX) project id only.
If the project id is used, then the C<MASTER_INBOX> folder is used as source and destination.

Example source and destination directories:

 /proj/sllstore2017xxx/MASTER_INBOX -> /dnadata/projects/nrmuser/MASTER_INBOX

Generates file C<< rsync-E<lt>projidE<gt>-E<lt>dateE<gt>.E<lt>iE<gt>.slurm >> in the current working directory.

The user of the script needs to have accounts on both UPPMAX and NRM, and the script should be run on UPPMAX.

No extensive error checking. Run output script manually and look at output.

=head2 Transfer speed

Transfer speed between UPPMAX and NRM varies erratically (0.1 - >100 MB/s).
To estimate the time needed for the slurm script, I assume a transfer speed of 20MB/s, and add 20%.
This value will probably need to be adjusted.
Note: 1 Mbps = 0.125 MB/s.

=head2 NRM authentication

Authentication to NRM server is done using SSH-keys: Your C<rda_sa.pub> needs to be know to NRM-IT.
Internally, NRM user name is send in the form C<"nrmuser@nrm.se"> (and not as C<NRM\\nrmuser> or C<nrmuser>).

=head1 OPTIONS

=over 8

=item B<-f, --findmasterinbox=E<lt>/path/to/folderE<gt>>

Locate MASTER_INBOX starting at the given folder (e.g. '/proj/sllstore2017xxx').

=item B<-s, --submit>

Submit to cluster (calling C<sbatch>). Default: B<-nosubmit>.

=item B<-m, --mail-user=E<lt>emailE<gt>>

Send messages from the cluster to <email>.

=item B<-n, --nrm-user=E<lt>userE<gt>>

User on NRM.

=item B<-c, --cpuaccount=E<lt>accountid<gt>>

Account for compute hours on UPPMAX, e.g. 'snic2017-1-xxx'.

=item B<-t, --time=E<lt>timeE<gt>>

Set run time for script. Use format C<D-H:MM:SS>, e.g. C<0-3:00:00>.

=item B<-a, --autotime=E<lt><intE<gt>>

Try to estimate optimal runtime. The estimated time is multiplied by an integer (default:3)
to add some extra time margin. This integer can be changed using, e.g. B<-noautotime=4>.
Default is to not use the autotime.

=item B<-h, --help>

Help text.

=back

=head1 TODO

=over

=item * How does script behave if no ssh keys? dd will fail there: capture error then, or before?

=item * If time less than 15(?) mins, use devcore partition?

=item * Test different rsync+ssh options for speed.

=item * Change $nrmuser to (empty) values for master script and test!

=back

=head1 AUTHOR

Johan Nylander L<<johan.nylanderATnrm.se>>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2017,2018 by Johan Nylander.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut

